---
title: "All About Copy Constructor in C++ With Example"
date: "2019-09-11"
categories: 
  - "cpp"
tags: 
  - "c-copy-constructor-assignment-operator"
  - "c-default-copy-constructor"
  - "c-program-for-copy-constructor"
  - "c-string-copy-constructor"
  - "copy-constructor"
  - "copy-constructor-and-assignment-operator"
  - "copy-constructor-and-assignment-operator-in-c"
  - "copy-constructor-c-example"
  - "copy-constructor-definition"
  - "copy-constructor-example"
  - "copy-constructor-example-in-c"
  - "copy-constructor-in-c-plus-plus"
  - "copy-constructor-in-c-example"
  - "copy-constructor-in-c-example-program"
  - "copy-constructor-in-c-pdf"
  - "copy-constructor-in-c-program"
  - "copy-constructor-in-c-simple-program"
  - "copy-constructor-in-c-syntax"
  - "copy-constructor-in-c-with-example"
  - "copy-constructor-in-oops"
  - "copy-constructor-program"
  - "copy-constructor-program-in-c"
  - "copy-constructor-syntax"
  - "cpp-copy-constructor"
  - "deep-copy-constructor-c"
  - "default-copy-constructor"
  - "default-copy-constructor-in-c"
  - "define-copy-constructor"
  - "define-copy-constructor-in-c"
  - "definition-of-copy-constructor-in-c"
  - "example-for-copy-constructor-in-c"
  - "example-of-copy-constructor-in-c"
  - "explain-copy-constructor"
  - "explain-copy-constructor-in-c"
  - "explain-copy-constructor-with-example"
  - "how-bitwise-copy-memberwise-copy"
  - "not-bitwise-copy-semantics"
  - "not-copy-constructor"
  - "other-ways-can-copy-constructor-be-invoked"
  - "program-for-copy-constructor-in-c"
  - "program-of-copy-constructor-in-c"
  - "simple-example-of-copy-constructor-in-c"
  - "simple-program-for-copy-constructor-in-c"
  - "syntax-of-copy-constructor-in-c-move-semantics-c-11"
  - "types-of-copy-constructor-in-c"
  - "use-of-copy-constructor"
  - "use-of-copy-constructor-in-c"
  - "where-copy-constructor"
  - "why-copy-constructor"
cover:
    image: /images/2-wrong-way-to-learn-copy-assignment-operator-in-c.png
---

Do not carry away with the title "All about copy constructor in C++ with example". In this article, I am not going to describe what copy constructor in C++ is. There is plenty of material available for that over the internet. Rather we will discuss why, where & how it used, how compiler synthesizes it for you and in what scenarios it called or not synthesized.

### Why: Copy Constructor

The simple answer is to copy the data within the same data types, but if you want more concrete idea then see below image:

<figure>

![All about copy constructor in C++](/images/copy-constructor-1.png)

<figcaption>

**Note**: Color represents assembly generated by the compiler for a corresponding C expression

</figcaption>

</figure>

- As you can see, for creating a copy within the same primitive data types like `char`, `int`, `float`, `long double`, etc. compiler has special instructions.
- But when you declare user-defined data type i.e. class/struct. The compiler does not have instruction for that because you are the owner of your type, so you have to define the copy operation in special member function called copy constructor suggesting compiler the way you want to copy.
- Whenever the situation of copy occurs compiler will simply substitute that expression with your copy constructor method.

### Where: Copy Constructor

- Object initialization by another object of the same class/type.

```cpp
class X { ... };
X x;

// Copy constructor will be called
X xx = x;
```

- When an object passed as an argument to a function

```cpp
extern void foo( X x );
void bar()
{
  X xx;

  // Copy constructor will be called
  foo( xx );

  // ...
}
```

- When a function returns a class object

```cpp
X foo_bar()
{
  X xx;
  // ...;

  // Copy constructor will be called
  return xx;
}
```

### Not: Copy Constructor

- The compiler will not synthesize copy constructor if class having a base class or [sub-object](/posts/memory-layout-of-cpp-object/) with the deleted copy constructor.

```cpp
struct base {
    base() = default;
    base(const base&) = delete;
};

struct derived : public base{ };

int main()
{
    derived d1;
    derived d2(d1);
    return 0;
}
```

- In this case, [derived class copy constructor will be deleted implicitly](https://stackoverflow.com/questions/37233407/call-to-implicitly-deleted-default-constructor-of-error/37233584). See below error for reference:

```cpp
error: call to implicitly-deleted copy constructor of
      'derived'
  derived d2(d1);
          ^  ~~
note: copy constructor of 'derived' is implicitly deleted
      because base class 'base' has a deleted copy constructor
struct derived : public base{ };
                 ^
note: 'base' has been explicitly marked deleted here
    base(const base&) = delete;
    ^
1 error generated.
compiler exit status 1
```

- Same stands true for [move constructor](/posts/lvalue-rvalue-and-their-references-with-example-in-cpp/) & [copy/move assignment operator](/posts/2-wrong-way-to-learn-copy-assignment-operator-in-cpp-with-example/).

### How: Bitwise Copy & Memberwise Copy

```cpp
#include "Word.h"

Word noun( "block" );

void foo()
{
  Word verb = noun;
  // ...
}
```

- If class `word` defined as follows, then it **exhibits bitwise copy constructor** as the initialization of `verb` need not result in a function call.

```cpp
class Word {
  public:
    Word( const char* );
    ~Word() { delete [] str; }
    // ...
  private:
    int cnt;
    char *str;
};
```

- But, if the class `word` defined as follows, then it exhibits memberwise copy constructor & result in a [function call](/posts/how-c-program-convert-into-assembly/) because string declares explicit copy constructor.

```cpp
class Word {
  public:
    Word( const string& );
    ~Word();
    // ...
  private:
    int cnt;
    string str;
};
```

- In this case, the compiler needs to synthesize a copy constructor as follows in order to invoke the copy constructor of the member class `string` object:

```cpp
// A synthesized copy constructor
inline Word::Word( const Word& wd )
{
  str.string::string( wd.str );
  cnt = wd.cnt;
}
```

### Not: Bitwise Copy Semantics..!

When bitwise copy semantics not exhibited by a class? There are four instances:

1. When the class contains a member object of a class for which a copy constructor exists (either explicitly declared by the class designer, as in the case of the previous `string` class, or synthesized by  
    the compiler, as in the case of class `Word`)
2. When the class derived from a base class for which a copy constructor exists (again, either explicitly  
    declared or synthesized)
3. When the class declares one or more [virtual functions](/posts/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/)
4. When the class derived from an inheritance chain in which one or more [virtual base classes](/posts/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally/) exist

In instances 1 & 2, the implementation needs to insert invocations of the member or base class copy constructors inside the synthesized copy constructor.

### Other Ways: Can Copy Constructor Be Invoked

```cpp
  X x0;
  X x1( x0 );
  X x2 = x0;
  X x3 = x( x0 );
  // ...
```

- All these statements transform into the invocation of the copy constructor.

```cpp
X x0;
X x1;
X x2;
X x3;
// compiler inserted invocations
// of copy constructor for X
x1.X::X( x0 );
x2.X::X( x0 );
x3.X::X( x0 );
// ...
```

copy constructor in C++ with example
